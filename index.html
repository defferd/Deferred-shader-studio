<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Deferred Shader Studio</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root {
            --mc-dark: #121212;
            --mc-blue: #3a86ff;
            --mc-water: #1a9fff;
            --mc-ui: rgba(30, 30, 30, 0.95);
            --mc-slider: #3a86ff;
            --mc-nethered: #ff3a3a;
            --mc-endpurple: #9d00ff;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: var(--mc-dark);
            color: white;
        }
        #app {
            display: grid;
            grid-template-columns: minmax(300px, 380px) 1fr;
            height: 100vh;
        }
        #controls {
            background: var(--mc-ui);
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border-right: 1px solid #333;
        }
        #previews {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 1px;
            background: #000;
        }
        .preview-container {
            position: relative;
            overflow: hidden;
        }
        .preview-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 3px;
            z-index: 10;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .control-group {
            margin-bottom: 25px;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .control-group:hover {
            background: rgba(0,0,0,0.4);
            box-shadow: 0 0 15px rgba(58, 134, 255, 0.2);
        }
        h2 {
            margin-top: 0;
            color: var(--mc-blue);
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }
        label {
            display: block;
            margin: 10px 0 5px;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--mc-slider);
            cursor: pointer;
            transition: all 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 5px var(--mc-slider);
        }
        input[type="color"] {
            width: 100%;
            height: 30px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #222;
            cursor: pointer;
        }
        button {
            background: var(--mc-blue);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            margin-top: 10px;
        }
        button:hover {
            background: #2a75e6;
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(58, 134, 255, 0.3);
        }
        .value-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #aaa;
            margin-top: 3px;
        }
        .performance-options {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        .performance-options label {
            display: inline-block;
            margin-right: 10px;
        }
        select {
            background: #222;
            color: white;
            border: 1px solid #333;
            padding: 5px;
            border-radius: 4px;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            cursor: help;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        @media (max-width: 768px) {
            #app {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            #previews {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(4, 50vh);
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Control Panel -->
        <div id="controls">
            <h1>Deferred Shader Studio</h1>
            
            <!-- Performance Options -->
            <div class="performance-options">
                <h2>‚öôÔ∏è Performance</h2>
                <label>
                    <input type="checkbox" id="realtime-updates" checked> Realtime Updates
                </label>
                <label>Preview Quality:
                    <select id="preview-quality">
                        <option value="high">High</option>
                        <option value="medium" selected>Medium</option>
                        <option value="low">Low</option>
                    </select>
                </label>
                <div id="active-previews">
                    <label>Active Previews:</label>
                    <label><input type="checkbox" class="preview-toggle" data-preview="overworld" checked> Overworld</label>
                    <label><input type="checkbox" class="preview-toggle" data-preview="nether" checked> Nether</label>
                    <label><input type="checkbox" class="preview-toggle" data-preview="end" checked> End</label>
                    <label><input type="checkbox" class="preview-toggle" data-preview="underwater" checked> Underwater</label>
                </div>
            </div>
            
            <!-- Lighting Controls -->
            <div class="control-group">
                <h2>‚òÄÔ∏è Directional Light</h2>
                <label>Sun Intensity
                    <span class="tooltip">‚ÑπÔ∏è<span class="tooltiptext">Controls the brightness of sunlight</span></span>
                </label>
                <input type="range" id="sun-intensity" min="0" max="5" step="0.1" value="1.0">
                <div class="value-display">
                    <span>0</span>
                    <span id="sun-intensity-value">1.0</span>
                    <span>5</span>
                </div>
                
                <label>Sun Color</label>
                <input type="color" id="sun-color" value="#fff4e6">
                
                <label>Sun Direction (Yaw)</label>
                <input type="range" id="sun-yaw" min="0" max="360" step="1" value="45">
                
                <label>Sun Direction (Pitch)</label>
                <input type="range" id="sun-pitch" min="-90" max="90" step="1" value="45">
                
                <label>Moon Illuminance</label>
                <input type="range" id="moon-intensity" min="0" max="1" step="0.01" value="0.27">
                <div class="value-display">
                    <span>0</span>
                    <span id="moon-intensity-value">0.27</span>
                    <span>1</span>
                </div>
            </div>
            
            <!-- PBR Materials -->
            <div class="control-group">
                <h2>‚ú® PBR Materials</h2>
                <label>Roughness</label>
                <input type="range" id="roughness" min="0" max="1" step="0.01" value="0.5">
                
                <label>Metallic</label>
                <input type="range" id="metallic" min="0" max="1" step="0.01" value="0.5">
                
                <label>Emissive Strength</label>
                <input type="range" id="emissive" min="0" max="2" step="0.1" value="0">
                
                <label>Preview Geometry:
                    <select id="preview-geometry">
                        <option value="box">Box</option>
                        <option value="sphere">Sphere</option>
                        <option value="plane">Plane</option>
                    </select>
                </label>
            </div>
            
            <!-- Volumetric Fog -->
            <div class="control-group">
                <h2>üå´Ô∏è Volumetric Fog</h2>
                <label>Density</label>
                <input type="range" id="fog-density" min="0" max="1" step="0.01" value="0.2">
                
                <label>Height Falloff</label>
                <input type="range" id="fog-height" min="0" max="200" step="1" value="150">
                
                <label>Fog Color</label>
                <input type="color" id="fog-color" value="#a0d0ff">
            </div>
            
            <!-- Water Settings -->
            <div class="control-group">
                <h2>üåä Water Effects</h2>
                <label>Wave Intensity</label>
                <input type="range" id="wave-intensity" min="0" max="2" step="0.1" value="0.8">
                
                <label>Water Color</label>
                <input type="color" id="water-color" value="#1a9fff">
                
                <label>Caustics Strength</label>
                <input type="range" id="caustics" min="0" max="1" step="0.1" value="0.7">
                
                <label>Water Clarity</label>
                <input type="range" id="water-clarity" min="0.1" max="1" step="0.05" value="0.5">
            </div>
            
            <!-- Biome-Specific Overrides -->
            <div class="control-group">
                <h2>üåç Biome Overrides</h2>
                <label>Nether Glow Intensity</label>
                <input type="range" id="nether-glow" min="0" max="2" step="0.1" value="0.5">
                
                <label>End Sky Brightness</label>
                <input type="range" id="end-brightness" min="0" max="1" step="0.05" value="0.3">
            </div>
            
            <button id="export-btn">Export Shader Pack (.mcpack)</button>
            <button id="save-preset">Save Preset</button>
            <button id="load-preset">Load Preset</button>
            <button id="undo-btn">Undo</button>
            <button id="redo-btn">Redo</button>
        </div>
        
        <!-- Preview Panes -->
        <div id="previews">
            <div class="preview-container" id="overworld">
                <div class="preview-label">Overworld</div>
                <canvas></canvas>
            </div>
            <div class="preview-container" id="nether">
                <div class="preview-label">Nether</div>
                <canvas></canvas>
            </div>
            <div class="preview-container" id="end">
                <div class="preview-label">The End</div>
                <canvas></canvas>
            </div>
            <div class="preview-container" id="underwater">
                <div class="preview-label">Underwater</div>
                <canvas></canvas>
            </div>
        </div>
    </div>

    <script>
        // Add this FIRST in your script
try {
    console.log("Three.js loading check...");
    
    if (typeof THREE === 'undefined') {
        throw new Error("Three.js not loaded!");
    }
    
    console.log("Three.js version:", THREE.REVISION);
    console.log("WebGLRenderer exists:", !!THREE.WebGLRenderer);
    
    if (!THREE.WebGLRenderer) {
        alert("WebGL support missing!");
    }
} catch (error) {
    console.error("Three.js initialization failed:", error);
    alert("CRITICAL ERROR: " + error.message);
    document.body.innerHTML = `<h1 style="color:red">${error.message}</h1>`;
    throw error; // Stop execution
}
        // Main Application Class
        class DeferredShaderStudio {
            constructor() {
                this.params = {
                    sunIntensity: 1.0,
                    sunColor: new THREE.Color(0xfff4e6),
                    sunYaw: 45,
                    sunPitch: 45,
                    moonIntensity: 0.27,
                    roughness: 0.5,
                    metallic: 0.5,
                    emissive: 0,
                    fogDensity: 0.2,
                    fogHeight: 150,
                    fogColor: new THREE.Color(0xa0d0ff),
                    waveIntensity: 0.8,
                    waterColor: new THREE.Color(0x1a9fff),
                    caustics: 0.7,
                    waterClarity: 0.5,
                    netherGlow: 0.5,
                    endBrightness: 0.3,
                    previewGeometry: 'box',
                    previewQuality: 'medium',
                    realtimeUpdates: true
                };
                
                this.scenes = {};
                this.history = [];
                this.historyIndex = -1;
                this.updateTimeout = null;
                this.initScenes();
                this.setupControls();
                this.animate();
                this.saveState();
            }
            
            initScenes() {
                const biomes = ['overworld', 'nether', 'end', 'underwater'];
                biomes.forEach(biome => {
                    const container = document.getElementById(biome);
                    const canvas = container.querySelector('canvas');
                    this.scenes[biome] = this.createBiomeScene(biome, canvas);
                });
                this.updatePreviewQuality();
            }
            
            createBiomeScene(biome, canvas) {
                // Scene setup
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ 
                    canvas,
                    antialias: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                
                // Biome-specific environment
                switch(biome) {
                    case 'nether':
                        scene.background = new THREE.Color(0x330000);
                        // Add point lights for lava glow
                        const lavaLight1 = new THREE.PointLight(0xff6600, this.params.netherGlow, 10);
                        lavaLight1.position.set(2, 0, 2);
                        scene.add(lavaLight1);
                        const lavaLight2 = new THREE.PointLight(0xff3300, this.params.netherGlow, 10);
                        lavaLight2.position.set(-2, 0, -2);
                        scene.add(lavaLight2);
                        break;
                    case 'end':
                        scene.background = new THREE.Color(0x110022);
                        // Add ambient light for end brightness
                        const endLight = new THREE.AmbientLight(0x9d00ff, this.params.endBrightness);
                        scene.add(endLight);
                        break;
                    case 'underwater':
                        scene.background = this.params.waterColor.clone().multiplyScalar(0.5);
                        break;
                    default:
                        scene.background = new THREE.Color(0x87CEEB);
                }
                
                // Create test geometry based on current selection
                this.createPreviewGeometry(scene, biome);
                
                // Lighting
                const sunLight = new THREE.DirectionalLight(0xffffff, this.params.sunIntensity);
                this.updateSunPosition(sunLight);
                scene.add(sunLight);
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
                scene.add(ambientLight);
                
                camera.position.z = 5;
                new THREE.OrbitControls(camera, canvas);
                
                return { 
                    scene, 
                    camera, 
                    renderer, 
                    sunLight, 
                    ambientLight,
                    testMesh: scene.children.find(child => child.isMesh),
                    active: true
                };
            }
            
            createPreviewGeometry(scene, biome) {
                // Remove existing test mesh if it exists
                const existingMesh = scene.children.find(child => child.isMesh);
                if (existingMesh) scene.remove(existingMesh);
                
                let geometry;
                switch(this.params.previewGeometry) {
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(1, 32, 32);
                        break;
                    case 'plane':
                        geometry = new THREE.PlaneGeometry(2, 2);
                        break;
                    default:
                        geometry = new THREE.BoxGeometry();
                }
                
                // Special material for underwater scene
                const material = biome === 'underwater' 
                    ? this.createWaterMaterial()
                    : new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        roughness: this.params.roughness,
                        metalness: this.params.metallic,
                        emissive: new THREE.Color(0x000000).multiplyScalar(this.params.emissive)
                    });
                
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
                
                // Store reference to the test mesh
                if (this.scenes[biome]) {
                    this.scenes[biome].testMesh = mesh;
                }
            }
            
            createWaterMaterial() {
                return new THREE.MeshStandardMaterial({
                    color: this.params.waterColor,
                    roughness: 0.1,
                    metalness: 0.9,
                    transparent: true,
                    opacity: this.params.waterClarity,
                    emissive: new THREE.Color(0x000000).multiplyScalar(this.params.emissive)
                });
            }
            
            updateSunPosition(sunLight) {
                const yawRad = THREE.MathUtils.degToRad(this.params.sunYaw);
                const pitchRad = THREE.MathUtils.degToRad(this.params.sunPitch);
                
                sunLight.position.x = Math.cos(yawRad) * Math.cos(pitchRad) * 5;
                sunLight.position.y = Math.sin(pitchRad) * 5;
                sunLight.position.z = Math.sin(yawRad) * Math.cos(pitchRad) * 5;
                
                sunLight.target.position.set(0, 0, 0);
                sunLight.target.updateMatrixWorld();
            }
            
            setupControls() {
                // Connect all sliders to parameters
                document.querySelectorAll('input[type="range"], input[type="color"], select').forEach(control => {
                    const display = document.getElementById(`${control.id}-value`);
                    if (display) display.textContent = control.value;
                    
                    control.addEventListener('input', (e) => {
                        let value;
                        if (e.target.type === 'color') {
                            value = new THREE.Color(e.target.value);
                        } else if (e.target.type === 'range') {
value = parseFloat(e.target.value);
                        } else {
                            value = e.target.value;
                        }
                        
                        this.params[e.target.id.replace('-', '')] = value;
                        
                        // Update display if exists
                        if (display) display.textContent = value;
                        
                        this.queueUpdate();
                    });
                });
                
                // Checkboxes
                document.getElementById('realtime-updates').addEventListener('change', (e) => {
                    this.params.realtimeUpdates = e.target.checked;
                });
                
                // Preview toggles
                document.querySelectorAll('.preview-toggle').forEach(toggle => {
                    toggle.addEventListener('change', (e) => {
                        const biome = e.target.dataset.preview;
                        this.scenes[biome].active = e.target.checked;
                    });
                });
                
                // Export button
                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportShaderPack();
                });
                
                // Preset buttons
                document.getElementById('save-preset').addEventListener('click', () => {
                    this.savePreset();
                });
                
                document.getElementById('load-preset').addEventListener('click', () => {
                    this.loadPreset();
                });
                
                // Undo/redo
                document.getElementById('undo-btn').addEventListener('click', () => {
                    this.undo();
                });
                
                document.getElementById('redo-btn').addEventListener('click', () => {
                    this.redo();
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.onWindowResize();
                });
            }
            
            queueUpdate() {
                if (this.updateTimeout) clearTimeout(this.updateTimeout);
                
                if (this.params.realtimeUpdates) {
                    this.updateTimeout = setTimeout(() => {
                        this.updateSceneUniforms();
                        this.saveState();
                    }, 100); // Small delay to batch rapid changes
                } else {
                    this.saveState(); // Still save state but don't render
                }
            }
            
            updateSceneUniforms() {
                // Update all scenes with current parameters
                Object.entries(this.scenes).forEach(([biome, { scene, sunLight, testMesh }]) => {
                    if (!this.scenes[biome].active) return;
                    
                    // Update lighting
                    sunLight.intensity = this.params.sunIntensity;
                    sunLight.color.copy(this.params.sunColor);
                    this.updateSunPosition(sunLight);
                    
                    // Update materials
                    if (testMesh) {
                        if (biome === 'underwater') {
                            testMesh.material = this.createWaterMaterial();
                        } else {
                            testMesh.material.roughness = this.params.roughness;
                            testMesh.material.metalness = this.params.metallic;
                            testMesh.material.emissive
                                .set(0x000000)
                                .multiplyScalar(this.params.emissive);
                        }
                    }
                    
                    // Update biome-specific effects
                    switch(biome) {
                        case 'nether':
                            scene.children.forEach(child => {
                                if (child.isPointLight) {
                                    child.intensity = this.params.netherGlow;
                                }
                            });
                            break;
                        case 'end':
                            scene.children.forEach(child => {
                                if (child.isAmbientLight) {
                                    child.intensity = this.params.endBrightness;
                                }
                            });
                            break;
                        case 'underwater':
                            // Implement wave effect
                            if (testMesh) {
                                const time = Date.now() * 0.001;
                                testMesh.position.y = Math.sin(time) * 0.1 * this.params.waveIntensity;
                            }
                            break;
                    }
                    
                    // Update fog effect
                    scene.fog = new THREE.FogExp2(
                        this.params.fogColor.getHex(),
                        this.params.fogDensity * 0.1
                    );
                });
                
                // Update preview geometry if changed
                if (this.params.previewGeometry !== this.history[this.historyIndex]?.previewGeometry) {
                    Object.keys(this.scenes).forEach(biome => {
                        this.createPreviewGeometry(this.scenes[biome].scene, biome);
                    });
                }
            }
            
            updatePreviewQuality() {
                Object.values(this.scenes).forEach(({ renderer }) => {
                    switch(this.params.previewQuality) {
                        case 'high':
                            renderer.setPixelRatio(window.devicePixelRatio);
                            break;
                        case 'medium':
                            renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
                            break;
                        case 'low':
                            renderer.setPixelRatio(1);
                            break;
                    }
                });
            }
            
            onWindowResize() {
                Object.entries(this.scenes).forEach(([id, { renderer }]) => {
                    const container = document.getElementById(id);
                    if (container.clientWidth > 0 && container.clientHeight > 0) {
                        renderer.setSize(container.clientWidth, container.clientHeight);
                    }
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Render all active previews
                Object.entries(this.scenes).forEach(([biome, { scene, camera, renderer, active }]) => {
                    if (active) {
                        renderer.render(scene, camera);
                    }
                });
            }
            
            saveState() {
                // Trim history if we're not at the end
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }
                
                // Deep clone current params
                const state = JSON.parse(JSON.stringify(this.params));
                state.sunColor = this.params.sunColor.getHex();
                state.fogColor = this.params.fogColor.getHex();
                state.waterColor = this.params.waterColor.getHex();
                
                this.history.push(state);
                this.historyIndex = this.history.length - 1;
                
                // Limit history size
                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                this.updateUndoRedoButtons();
            }
            
            loadState(state) {
                this.params = JSON.parse(JSON.stringify(state));
                this.params.sunColor = new THREE.Color(state.sunColor);
                this.params.fogColor = new THREE.Color(state.fogColor);
                this.params.waterColor = new THREE.Color(state.waterColor);
                
                // Update UI controls
                document.getElementById('sun-intensity').value = this.params.sunIntensity;
                document.getElementById('sun-intensity-value').textContent = this.params.sunIntensity;
                document.getElementById('sun-color').value = `#${this.params.sunColor.getHexString()}`;
                // Update all other controls similarly...
                
                this.updateSceneUniforms();
                this.updateUndoRedoButtons();
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);
                }
            }
            
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);
                }
            }
            
            updateUndoRedoButtons() {
                document.getElementById('undo-btn').disabled = this.historyIndex <= 0;
                document.getElementById('redo-btn').disabled = this.historyIndex >= this.history.length - 1;
            }
            
            savePreset() {
                const presetName = prompt("Enter preset name:");
                if (presetName) {
                    const presets = JSON.parse(localStorage.getItem('shaderPresets') || '{}');
                    presets[presetName] = this.history[this.historyIndex];
                    localStorage.setItem('shaderPresets', JSON.stringify(presets));
                    alert(`Preset "${presetName}" saved!`);
                }
            }
            
            loadPreset() {
                const presets = JSON.parse(localStorage.getItem('shaderPresets') || '{}');
                const presetNames = Object.keys(presets);
                
                if (presetNames.length === 0) {
                    alert("No presets saved yet!");
                    return;
                }
                
                const selectedPreset = prompt(`Available presets:\n${presetNames.join('\n')}\n\nEnter preset name to load:`);
                if (selectedPreset && presets[selectedPreset]) {
                    this.loadState(presets[selectedPreset]);
                    alert(`Preset "${selectedPreset}" loaded!`);
                }
            }
            
            exportShaderPack() {
                const zip = new JSZip();
                
                // Generate materials file
                const materialsJSON = {
                    format_version: "1.16.100",
                    materials: {
                        pbr: {
                            textures: {
                                color: "textures/blocks/pbr_base",
                                metalness_emissive_roughness: "textures/blocks/pbr_mer"
                            },
                            definitions: {
                                "_roughness": this.params.roughness.toFixed(2),
                                "_metalness": this.params.metallic.toFixed(2),
                                "_emissive": this.params.emissive.toFixed(1)
                            }
                        }
                    }
                };
                
                // Generate fog settings
                const fogJSON = {
                    format_version: "1.16.100",
                    minecraft:fog_settings: {
                        description: { identifier: "custom:deferred_fog" },
                        volumetric: {
                            density: { 
                                air: { 
                                    max_density: this.params.fogDensity.toFixed(2),
                                    zero_density_height: this.params.fogHeight.toFixed(1)
                                }
                            },
                            media_coefficients: {
                                air: { 
                                    scattering: [0.02, 0.02, 0.02],
                                    absorption: [0.0, 0.0, 0.0] 
                                }
                            }
                        }
                    }
                };
                
                // Generate water settings
                const waterJSON = {
                    format_version: "1.21.80",
                    minecraft:water_settings: {
                        description: { identifier: "custom:deferred_water" },
                        waves: {
                            enabled: this.params.waveIntensity > 0,
                            depth: this.params.waveIntensity.toFixed(1),
                            frequency: 1.0
                        },
                        caustics: {
                            enabled: this.params.caustics > 0,
                            power: Math.round(this.params.caustics * 6)
                        }
                    }
                };
                
                // Add files to zip
                zip.file("materials/pbr.material", JSON.stringify(materialsJSON, null, 2));
                zip.file("fogs/deferred_fog.json", JSON.stringify(fogJSON, null, 2));
                zip.file("water/water_settings.json", JSON.stringify(waterJSON, null, 2));
                
                // Generate and download
                zip.generateAsync({ type: "blob" }).then(content => {
                    saveAs(content, "deferred_shader_pack.mcpack");
                });
            }
        }
        
        // Initialize when loaded
        window.addEventListener('load', () => {
            const studio = new DeferredShaderStudio();
        });
    </script>
</body>
</html>
